Spring Cloud OpenFeign



梳理：

启动流程：
1. 注册默认配置
2. 扫描 @FeignClient 注解的接口
3. 生成动态代理类并注入到 spring bean 中



org.springframework.cloud.openfeign.EnableFeignClients *
	-> org.springframework.cloud.openfeign.FeignClientsRegistrar *
		-> org.springframework.cloud.openfeign.FeignClientsRegistrar#registerBeanDefinitions    
			- org.springframework.context.annotation.ImportBeanDefinitionRegistrar
			-> org.springframework.cloud.openfeign.FeignClientsRegistrar#registerDefaultConfiguration
				-> org.springframework.cloud.openfeign.FeignClientsRegistrar#registerClientConfiguration 
					=> org.springframework.cloud.openfeign.FeignClientSpecification // org.springframework.beans.factory.support.BeanDefinitionBuilder
			-> org.springframework.cloud.openfeign.FeignClientsRegistrar#registerFeignClients
				-> org.springframework.cloud.openfeign.FeignClientsRegistrar#registerFeignClient *
					-> org.springframework.cloud.openfeign.FeignClientFactoryBean 
						- org.springframework.beans.factory.support.AbstractBeanDefinition
						- org.springframework.beans.factory.config.BeanDefinitionHolder
						- org.springframework.beans.factory.support.BeanDefinitionReaderUtils#registerBeanDefinition
					-> org.springframework.cloud.openfeign.FeignClientsRegistrar#registerOptionsBeanDefinition

					org.springframework.cloud.openfeign.FeignClientFactoryBean#getObject *
						-> org.springframework.cloud.openfeign.FeignClientFactoryBean#getTarget *
							- org.springframework.cloud.openfeign.FeignContext // org.springframework.cloud.openfeign.FeignAutoConfiguration
							-> org.springframework.cloud.openfeign.FeignClientFactoryBean#feign
							-> feign.Client
							-> org.springframework.cloud.openfeign.FeignClientFactoryBean#applyBuildCustomizers
								-> org.springframework.cloud.openfeign.FeignBuilderCustomizer
							-> org.springframework.cloud.openfeign.Targeter *
								-> org.springframework.cloud.openfeign.DefaultTargeter#target
									-> feign.Feign.Builder#target(feign.Target<T>)
										-> feign.Feign.Builder#build
											- Client client = Capability.enrich(this.client, capabilities);
											-> feign.SynchronousMethodHandler.Factory
											-> feign.ReflectiveFeign.ParseHandlersByName#ParseHandlersByName
											-> feign.ReflectiveFeign#ReflectiveFeign
										-> feign.Feign#newInstance
											-> feign.ReflectiveFeign#newInstance *
												-> nameToHandler - feign.ReflectiveFeign.ParseHandlersByName#apply
													-> feign.Contract#parseAndValidateMetadata
													-> feign.SynchronousMethodHandler.Factory#create
														-> feign.SynchronousMethodHandler#SynchronousMethodHandler
													=> Map<String, MethodHandler>
												- methodToHandler
												- defaultMethodHandlers
												-> InvocationHandler
													-> feign.InvocationHandlerFactory.Default#create

												T proxy = (T) Proxy.newProxyInstance(target.type().getClassLoader(),
        										new Class<?>[] {target.type()}, handler);

												defaultMethodHandler.bindTo(proxy);

												=> proxy




	- Feign.class					
org.springframework.cloud.openfeign.FeignAutoConfiguration *
	- FeignClientProperties.class
	- FeignHttpClientProperties.class
	- FeignEncoderProperties.class
	- FeignContext
	- CachingCapability
	- FeignJacksonConfiguration
	- DefaultFeignTargeterConfiguration
		=> DefaultTargeter
	- CircuitBreakerPresentFeignTargeterConfiguration
	- HttpClientFeignConfiguration
	- OkHttpFeignConfiguration
	- HttpClient5FeignConfiguration

org.springframework.cloud.openfeign.loadbalancer.FeignLoadBalancerAutoConfiguration
    -> org.springframework.cloud.openfeign.loadbalancer.DefaultFeignLoadBalancerConfiguration.feignClient
        -> org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient.FeignBlockingLoadBalancerClient(feign.Client, org.springframework.cloud.client.loadbalancer.LoadBalancerClient, org.springframework.cloud.loadbalancer.support.LoadBalancerClientFactory)


调用流程：

xxxFeignClient
 -> feign.ReflectiveFeign.FeignInvocationHandler#invoke
 	- Map<Method, MethodHandler> dispatch;
	-> feign.InvocationHandlerFactory.MethodHandler#invoke
		-> feign.SynchronousMethodHandler#invoke
			-> feign.SynchronousMethodHandler#executeAndDecode
			    -> feign.SynchronousMethodHandler.targetRequest
			        -> feign.RequestInterceptor.apply
			        -> feign.Target.HardCodedTarget.apply
			            -> feign.Target.HardCodedTarget.apply
			                -> feign.RequestTemplate.target
			                    -> feign.RequestTemplate.target
			                -> feign.RequestTemplate.request
			                    -> feign.Request.create(feign.Request.HttpMethod, java.lang.String, java.util.Map<java.lang.String,java.util.Collection<java.lang.String>>, feign.Request.Body, feign.RequestTemplate)
			    -> org.springframework.cloud.openfeign.loadbalancer.FeignBlockingLoadBalancerClient.execute
			        -> org.springframework.cloud.client.loadbalancer.ServiceInstanceChooser.choose(java.lang.String, org.springframework.cloud.client.loadbalancer.Request<T>)
			        -> org.springframework.cloud.openfeign.loadbalancer.LoadBalancerUtils.executeWithLoadBalancerLifecycleProcessing(feign.Client, feign.Request.Options, feign.Request, org.springframework.cloud.client.loadbalancer.Request, org.springframework.cloud.client.loadbalancer.Response<org.springframework.cloud.client.ServiceInstance>, java.util.Set<org.springframework.cloud.client.loadbalancer.LoadBalancerLifecycle>, boolean)
			            -> org.springframework.cloud.openfeign.loadbalancer.LoadBalancerUtils.executeWithLoadBalancerLifecycleProcessing(feign.Client, feign.Request.Options, feign.Request, org.springframework.cloud.client.loadbalancer.Request, org.springframework.cloud.client.loadbalancer.Response<org.springframework.cloud.client.ServiceInstance>, java.util.Set<org.springframework.cloud.client.loadbalancer.LoadBalancerLifecycle>, boolean, boolean)
			                -> feign.Client.Default.execute
			                    -> feign.Client.Default.convertAndSend
			                    -> feign.Client.Default.convertResponse
				-> feign.AsyncResponseHandler#handleResponse
				    -> feign.AsyncResponseHandler.decode
				        -> org.springframework.cloud.openfeign.support.ResponseEntityDecoder.decode
				            -> org.springframework.cloud.openfeign.support.SpringDecoder.decode
				                -> org.springframework.cloud.openfeign.support.SpringDecoder.FeignResponseAdapter
				                -> org.springframework.web.client.HttpMessageConverterExtractor.extractData
				                    -> org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter.readJavaType


问题：
1. 如何拦截的？不是通过拦截，是通过 jdk 动态代理
2. 动态代理类是如何创建的？ 在  FeignClientFactoryBean#getObject()中产生。


			































